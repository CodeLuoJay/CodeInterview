# Java基础

这个章节主要涉及Java语法、基本数据类型，修饰符，运算符，数组的面试题和核心知识

### Java开发相关命令

> ##### JDK、JRE、JVM之间区别和联系
>

JDK是Java Development Kit （Java开发**工具包**）是用来执行**编译Java源代码文件、解释和执行Java字节码**

JRE是Java Runtime Environment（Java**运行环境**）是用于**解释执行Java的字节码文件**

JVM是Java Virtual Mechinal（Java虚拟机），是**JRE的一部分**,它用来运行java字节码文件的**虚拟计算机**

它们之间的联系可以理解为它们之间的包含关系：**JDK>JRE>JVM**

即JDK包含JRE,JRE包含JVM,所以总的来说**JDK包含了JRE和JVM**

> ##### javac、javap、java之间的区别

javac是用来编译Java源文件即后缀名为.java文件，可以一次编译多个

javap是用来反编译Java字节码文件即后缀名为.class文件

java是用来运行java字节码文件

在初学Java的时候，入门书籍一般都会介绍到这三个命令，在校招和基础笔试题可能会考察这几个命令

### Java变量

Java变量依照作用域不同可以划分为以下三类

**类变量**：独立于方法之外的变量，用 static 修饰。
**实例变量**：独立于方法之外的变量，不过没有 static 修饰。
**局部变量**：类的方法中的变量。

```java
public class Test{

    static int allClicks=0;    // 类变量

    String str = "hello world";  // 实例变量

    public void method() {
        int i = 0;  // 局部变量
    }
}
```

### 实例变量

实例变量又称为成员变量，是类中的一个成员，声明在方法外面

- 声明位置：在一个类中，但在方法、构造方法和语句块之外
- 生命周期：在对象创建的时候创建，在对象被销毁的时候销毁
- 能否被修饰符修饰：实例变量可以访问修饰符可以修饰
- 内存分配：实例变量是在**堆**中分配的

- 是否有默认值：实例变量具有默认值，引用类型变量的默认值是null，基本类型变量就是基本数据的默认值


### 局部变量

局部变量是声明在成员方法里面的变量

- 声明位置：在方法、构造方法或者语句块中
- 生命周期：在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁
- 能否被修饰符修饰：访问修饰符不能用于局部变量
- 作用范围：局部变量只在声明它的方法、构造方法或者语句块中可见
- 内存分配：局部变量是在**栈**上分配的
- 是否有默认值：局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用

### 类变量

类变量也称为静态成员变量，在类中以 static 关键字声明，但必须在方法之外，无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。

- 声明位置：在方法之外，且带有static关键字修饰
- 静态变量：储存在静态存储区(又称为方法区)
- 生命周期：静态变量随类的加载创建，在程序结束时销毁
- 能否被修饰符修饰：类变量可以被访问修饰符修饰
- 是否有默认值：类变量有默认值，引用类型变量的默认值是null，基本类型变量就是基本数据的默认值

> ##### java中的类变量、成员变量、局部变量之间的区别

|          | 成员变量       | 局部变量                     | 静态变量           |
| -------- | -------------- | ---------------------------- | ------------------ |
| 初始化值 | 有默认初始化值 | 无 , 先定义 , 赋值后才能使用 | 有默认初始化值     |
| 调用方式 | 对象调用       | ---                          | 对象调用，类名调用 |
| 存储位置 | 堆中           | 栈中                         | 方法区             |
| 生命周期 | 与对象共存亡   | 与方法共存亡                 | 与类共存亡         |
| 别名     | 实例变量       | ---                          | 类变量             |

> ##### 下列Java代码中的变量a、b、c分别在内存的什么存储区存放？

```java
class A {
    private String a = “aa”;
    public boolean methodB() {
        String b = “bb”;
        final String c = “cc”;
    }
}
```

a为实例变量，存放在堆中，b为局部变量，存放在栈中，c因为final修饰是一个常量，且也在方法中声明的，为局部变量，也存放在栈中

来源：[牛客刷题](https://www.nowcoder.com/questionTerminal/51123ddacab84a158e121bc5fe3917eb)

比较好的理解:[浅谈JAVA中字符串常量的储存位置](https://www.cnblogs.com/zhaohongtian/p/6801302.html)

知乎有关常量的论述：[java中常量存放在哪？](https://www.zhihu.com/question/65624006)

对String字符串很好理解到位的题目[[堆，栈，方法区，常量池，的概念](https://www.cnblogs.com/xiaowangbangzhu/p/10366200.html)](https://www.cnblogs.com/xiaowangbangzhu/p/10366200.html)

[Java栈，PC寄存器，本地方法栈，堆，方法区和运行常量池](https://blog.csdn.net/dingguanyi/article/details/80759436)



### Java访问修饰符

Java语言提供了很多修饰符，主要分为以下两类：

- 访问修饰符
- 非访问修饰符 

修饰符用来定义类、方法或者变量，通常放在语句的最前端。

#### 访问修饰符

Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。

- default (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。**使用对象：类、接口、成员变量、成员方法。**
- private : 在同一类内可见。使用对象：变量、方法。 注意：**不能修饰类（外部类）**
- public : 对所有类可见。**使用对象：类、接口、成员变量、成员方法**
- protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：**不能修饰类（外部类）。**

| 修饰符|当前类|同 包|子 类|其他包|
| ---- | ---- | ---- | ---- | ---- |
| public|	√|	√|	√|	√|
|protected|	√|	√|	√|	×|
|default|	√|	√|	×|	×|
|private|	√|	×|	×|	×|

关于修饰符常考的是default、protected、private，具体需要区分以下规则

- 在类的成员不写（缺省的时候）修饰符时，使用的是默认访问修饰符声明的类的变量和方法，对同一个包内的类是可见的，关键词是**同一个包内的类**
- protected修饰符修饰成员方法和成员变量对**同一个包内的类**和**不是同一个包的子类**都是可见的
- private修饰符只有当前的类可见
- 外部类是不能被protected和privated修饰，只能有public和default这两个修饰符修饰

#### 访问修饰符控制和继承

访问修饰符的继承一般和方法的重写（方法覆盖）组合作为一个考点，来混淆考察面试者Java基础

请注意以下方法继承的规则：

- 父类中声明为 public 的方法在子类中也必须为 public。
- 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。
- 父类中声明为 private 的方法，不能够被继承。

>下面程序有错误吗？如有，请指出几处错误，如没有请说明原因

```java
public class B extends A{
    void methodA(){}	//	
    void methodB(){}	//	
    void methodC(){}	
    void methodD(){}
}
class A{
    public void methodA(){}
    protected void methodB(){}
    void methodC(){}
    private void methodD(){}
}
```

> 答案:有错，错误地方有两处

B继承A，要以A的修饰符为准，子类对父类的方进行重写的时候，子类方法访问修饰符一定不能小于父类的修饰符，换言而之，就是大于等于父类的访问修饰符

A和B方法有误，A方法的修饰符必须是public，B方法的修饰符可以是protected或者public，C方法修饰符在A和B类中一致，D方法在父类是私有的，不能继承，

在B中只能是重新定义的一个新方法，所以没有错误

### 非访问修饰符

为了实现一些其他的功能，Java 也提供了许多非访问修饰符，常被用到和考到有以下这些

- static 修饰符，用来修饰类方法和类变量。

- final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。

- abstract 修饰符，用来创建抽象类和抽象方法。

- synchronized 和 volatile 修饰符，主要用于线程的编程。

#### static 修饰符

**静态成员变量**：static 关键字用来声明独立于对象的静态成员变量

- 说明：无论一个类实例化多少对象，它的静态成员变量只有一份拷贝。 静态成员变量也被称为类变量。局部变量不能被声明为 static 变量。
- 调用方式：**类名.静态成员变量** 如ClassName.VariableName的方式访问。

**静态方法**：static 关键字用来声明独立于对象的静态方法

静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据

> ##### 在一个静态方法内调用一个非静态成员为什么是非法的?

从static修饰符的规定来讲：静态方法不能使用类的非静态变量（非静态成员）

从JVM规范来讲：静态方法是随类的加载而加载的，非静态成员归属对象特有的数据，要在对象实例化后才能使用，并且类的加载先于对象的实例化，

所以静态方法调用非静态成员为什么是非法的

#### final 修饰符

final 表示"最后的、最终的"含义，变量一旦赋值后，不能被重新赋值。

**final修饰变量**

final修饰的变量，会成为不可以改变的常量，且被 final 修饰的**实例变量**必须**显式指定初始值**。

final 修饰符通常和 static 修饰符一起使用来创建类常量。

**final 修饰方法**

final修饰方法可以被子类继承但子类中不可以重写，所以声明 final 方法的主要目的是防止该方法的内容被修改。

**final 修饰类**

final 类不能被继承，没有类能够继承 final 类的任何特性。

#### abstract 修饰符

**abstract修饰类**

abstract修饰的类是抽象类，抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。

- 一个类不能同时被 abstract 和 final 修饰，因为抽象类需子类重写父类方法，final修饰类不能继承，两者矛盾
- 如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。
- 抽象类可以包含抽象方法和非抽象方法。

**abstract修饰方法**

abstract修饰方法是一种没有任何实现的抽象方法，**该方法的的具体实现由子类提供**。

- 抽象方法不能被声明成 final 和 static。

- 任何继承抽象类的子类必须实现父类的**所有抽象**方法，除非**该子类也是抽象类**。
- 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。**抽象类可以不包含抽象方法**。

**synchronized 修饰符**

synchronized 修饰的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。

**transient 修饰符**

序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。

该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。

```Java
public transient int limit = 55;   // 不会持久化
public int b; // 持久化
```

**volatile 修饰符**

volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。**一个 volatile 对象引用可能是 null**。

### Java 运算符

运算符是每门语言的基本功，在校招面试中，出现运算符的笔试题和面试题会比较高，所以在本文中只会针对常考的运算符进行总结

- 算术运算符中，主要是自增和自减运算符
- 位运算符，主要是按位与、按位或、按位异或、按位取反，按位左移、按位右移、按位右移补零操作符
- instanceof 运算符
- 赋值运算符

运算符优先级

![img](https://bobi-1258060032.cos.ap-chengdu.myqcloud.com/CodeInterview/1001990-20161025144757265-1724289762.png)

自增运算符

> #### 经典的自增运算题目

```Java
public class IncreaseVariableExample {
    public static void main(String[] args) {
        int j = 0;
        for (int i = 0; i < 100; i++) {
            j = j++;
        }	
        System.out.println(j);
    }
}
```

可能会有不少人认为输出是100，但实际输出是0；这其实就涉及到JVM相关的知识以及字节码相关指令，

经过反编译得到字节码，主要是针对`j = j++`这一行代码说明下面三行字节码

```shell
10: iload_1	//	将本地变量j=0 值压入栈顶
11: iinc    //  本地变量j（也叫局部变量）自增,j=1
14: istore_1//	将栈顶的操作数也就是j=0这个操作数，重新赋值给j，如此循环100次，j最后等于0
```

> 如果将`j =  j++`分别改成 `j = ++j`、`j++`、`++j`这三个值，思考一下会输出什么结果？

如果想知道正确的答案，可以参考知乎一位阿里巴巴大佬的博文 [关于自增操作，你真的懂了吗？](https://zhuanlan.zhihu.com/p/35133459)

> #### 自减运算题目

```Java
 public static void main(String[] args) {
        int a =100,b=50,c=a---b,d=a---b;
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
 }
```

这个题目其实是考察了自减运算和运算符的优先级这两个点，c和d可以改写成`c = (a--)-b`，`d = (a--)-b`

- 首先能确定b=50，其次来计算c
- `c = (a--)-b` 计算过程是这样过程，a压入栈，此时a=100，a本地变量自减（局部变量表a=99），b压入栈此时b=50，然后运算相减操作，将入栈a=100和b=50相减后将操作数结果出栈，存进局部变量表c，c=50
- `d = (a--)-b`，由上一步操作，a=99的值压入栈，a本地变量自减（局部变量表a=98），b压入栈，最后a=99和b=50相减的结果出栈，存进本地变量表d=49

> 最后结果：98 50 50 49

此类题目，还有比较综合一点的面试题，也是考察基本的运算符优先级、运算优先级、以及自增操作的过程理解

```java
public class VariableIncrementSample {
    public static void main(String[] args) {
        int i = 1;
        i = i++;
        int j = i++;
        int k = i + ++i * i++;
        System.out.println("i="+i);
        System.out.println("j="+j);
        System.out.println("k="+k);
    }
}
```

按照我自己的理解是这样一个计算过程的

1. `i=i++` 本地变量i=1 入栈，本地变量i自增，然后将栈顶的i=1的值存回本地变量表i中，最后i=1

2. `j=i++`上一步本地变量i=1，这一步也是一样，本地变量i=1压入栈，本地变量i自增，然后将栈顶的i=1存回本地变量j中，j=1，本地变量表i=2

3. `k=i + ++i * i++` 这一步是这一题的考察点核心，运算符优先级 自增优先级高于加减乘除，变量入栈操作是从左往后开始的，也就是说先把 i 压入栈，然后轮到++i，最后到 i++，最后才算相乘，相减，赋值

4. 上一步本地变量i=2压入栈，然后到 ++i，++i的过程是 本地变量i自增变成 i=3，然后再入栈，紧接着就是 i++，i++过程是 本地变量i=3入栈，本地变量i自增变成4，至此完成变量的初始化操作（即入栈操作）

5. 下面就开始出栈操作，经过上面的操作，k的运算式子变成 `int k = 2 + 3 * 3 `,结果很显然易见等于11

6. 那么计算机是怎么计算出11的过程，首先我们知道第四步中，入栈三个操作数，自顶向下是3、3、2，那么3*3的结果弹上栈顶，然后9+2的结果弹上栈顶，最后11出栈

   